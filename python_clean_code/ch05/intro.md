# 5장 데코레이터를 사용한 코드 개선

이 장의 목표
- 파이썬에서 데코레이터가 동작하는 방식을 이해한다.
- 함수와 클래스에 적용되는 데코레이터를 구현하는 방법을 배운다.
- 일반적인 실수를 피하여 데코레이터를 효과적으로 구현하는 방법을 배운다.
- 데코레이터를 활용한 코드 중복을 회피 - DRY 원칙 준수
- 데코레이터를 활용한 관심사의 분리
- 좋은 데코레이터 사례
- 데코레이터가 좋은 선택이 될 수 있는 일반적인 상황, 관용구, 패턴

5장에서는 데코레이터 하나만 집중적으로 알아본다. 평소에도 자주 사용되는 기능을 데코레이터로 만들어서 사용하곤 했는데, 그때마다 구글링해서 해결했던 것 같다. 이번 기회에 데코레이터를 자세히 알아보고 제대로 활용해보도록 해야겠다.

---

## 파이썬의 데코레이터

original이라는 함수가 있고 그 기능을 약간 수정한 modifier라고 하는 함수가 있는 경우 다음과 같이 작성해야한다.
```python
def original(...):
...
original = modifier(original)
```
이것은 혼란스럽고 오류가 발생하기 쉽고 번거롭다. (함수를 재할당하는 것을 잊어버리거나 함수 정의가 멀리 떨어져 있는 경우) 이러한 이유로 새로운 구문이 추가되었다.

```python
@modifier
def original(...):
    ...
```
modifier는 파이썬 용어로 데코레이터라 하고, original을 `데코리이팅된` 함수 혹은 `래핑된` 객체라 한다.

데코레이터는 데코레이터 이후에 나오는 것을 데코레이터의 첫 번째 파라미터로 하고 데코레이터의 결과 값을 반환하게 하는 `문법적 설탕(syntax sugar)`<sup>[1](#footnote_1)</sup>일 뿐이다.

함수와 메서드, 제너레이터, 클래스에 데코레이터를 적용하는 방법을 살펴보자.

---

### 함수 데코레이터

파이썬에서 데코레이터를 사용하여 기능을 변경하는 가장 간단한 방법은 함수에 적용하는 것이다.

- 파라미터의 유효성을 검사하거나
- 사전조건을 검사하거나
- 기능 전체를 새롭게 정의할 수도 있고
- 서명을 변경할 수도 있고
- 원래 함수의 결과를 캐시하는 등의 작업을 모두 할 수 있다.

### 클래스 데코레이터

함수 데코레이터와의 차이점은 데코레이터가 파라미터로 클래스를 받는다는 점이다.

어떤 개발자들은 클래스 데코레이터가 복잡하고 가독성을 떨어뜨릴 수 있다고 말할 수 있다. 왜냐하면 클래스에서 정의한 속성과 메서드를 데코레이터를 안에서 완전히 다른 용도로 변경할 수 있기 때문이다.

이 문제에 대한 장단점은 `데코레이터와 관심사의 분리`에서 살표보고 지금은 클래스 데코레이터의 장점에 대해 살펴본다.

- 코드 재사용과 DRY 원칙의 모든 이점을 공유한다.
- 당장은 작고 간단한 클래스를 생성하고 나중에 데코레이터로 기능을 보강할 수 있다.
- 어떤 클래스에 대해서는 유지보수 시 데코레이터를 사용해 기존 로직을 훨씬 쉽게 변경할 수 있다. 메타클래스와 같은 방법을 사용해 보다 복잡하게 만드는 것은 주로 권장되지 않는다.

`02_decorator_class.py`처럼 사용이 가능하다. 이 방법은 처음에는 잘 동작하지만, 시간이 지나면서 시스템을 확장할수록 다음과 같은 문제가 발생하게 된다.

- 클래스가 너무 많아진다.: 이벤트 클래스와 직렬화 클래스가 1대 1로 매핑되어 있으므로 직렬화 클래스가 점점 많아지게 된다.
- 이러한 방법은 충분히 유연하지 않다.: 만약 password를 가진 다른 클래스에서도 이 필드를 숨기려면 함수로 분리한 다음 여러 클래스에서 호출해야 한다. 이는 코드를 충분히 재사용했다고 볼 수가 없다.
- 표준화: serialize() 메서드는 모든 이벤트 클래스에 있어야만 한다. 비록 믹스인을 사용해 다른 클래스로 분리할 수 있지만 상속을 제대로 사용했다고 볼 수 없다.

또 다른 방법은 이벤트 인스턴스와 변형 함수를 필터로 받아서 동적으로 객체를 만드는 것이다. 필터를 이벤트 인스턴스의 필드들에 적용해 직렬화하는 것이다.

`02_decorator_class_refactoring.py`처럼 데코레이터를 사용하면 다른 클래스의 코드를 확인하지 않고도 각 필드가 어떻게 처리되는지 쉽게 알 수 있다.
클래스 데코레이터에 전달된 인수로 파악이 가능하다. 

### 다른 유형의 데코레이터

이제 데코레이터의 @ 구문이 실제로 무엇을 의미하는지 알았으므로 데코레이터가 단지 함수나 메서드, 클래스에만 적용되지 않는다는 것도 알 수 있다.
사실 제너레이터나 코루틴, 심지어 이미 데코레이트된 객체도 데코레이트 가능하다. `즉 데코레이터는 스택 형태로 쌓일 수 있다.`

### 데코레이터의 인자 전달

파라미터를 전달받아 로직을 추상화한다면 더욱 강력해질 수 있다.
파라미터를 갖는 데코레이터 구현 방법
1. 간접 참조<sup>[2](#footnote_2)</sup>를 통해 새로운 레벨의 중첩 함수를 만들어 데코레이터의 모든 것을 한 단계 더 깊게 만드는 것
2. 데코레이터를 위한 클래스를 만드는 것

일반적으로 두 번째 방법이 가독성이 더 좋음. 세 단계 이상 중첩된 클로저 함수보다는 객체가 이해하기 쉽기 때문.

#### 중첩 함수의 데코레이터
`크게 보면 데코레이터는 함수를 파라미터로 받아서 함수를 반환하는 함수이다.` 이런 함수를 고차 함수(higher-order function)라고 부른다. 실제로는 데코레이터의 본문에 정의된 함수가 호출된다.

이제 데코레이터를 파라미터에 전달하려면 다른 수준의 간접 참조가 필요하다. 첫 번째 함수는 파라미터를 받아서 내부 함수에 전달한다. 두 번째 함수는 데코레이터가 될 함수다. 세 번째는 데코레이팅의 결과를 반환하는 함수이다. 즉 최소 세 단계의 중첩 함수가 필요하다는 뜻이다.

이해가 안간다. 다음 예제를 보면서 정확히 이해 해보자.

#### 데코레이터 객체

중첩 함수의 데코레이터보다 깔끔하게 구현하기 위해 클래스를 사용하여 데코레이터를 정의할 수 있다. 이 경우 `__init__` 메서드에 파라미터를 전달한 다음 `__call__`이라는 매직 메서드에서 데코레이터의 로직을 구현하면 된다. 그 예는 `03_decorator_object.py`에서 확인!

여기서 파이썬 구문이 어떻게 처리되는지 이해하는 것이 중요하다. 먼저 @ 연산 전에 전달된 파라미터를 사용해 데코레이터 객체를 생성한다. 데코레이터 객체는 `__init__` 메서드에서 정해진 로직에 따라 초기화를 진행한다. 그 다음 @ 연산이 호출된다. 데코레이터 객체는 run_with_custom_retries_limit 함수를 래핑하여 `__call__` 매직 메서드를 호출한다.

---

### 데코레이터 활용 우수 사례
- 파라미터 변환: 더 멋진 API를 노출하기 위해 함수의 서명을 변경하는 경우. 이 때 파라미터가 어떻게 처리되고 변환되는지를 캡슐화하여 숨길 수 있다.
- 코드 추적: 파라미터와 함께 상수의 실행을 로깅하려는 경우
- 파라미터 유효성 검사
- 재시도 로직 구현
- 일부 반복 작업을 데코레이터로 이동하여 클래스 단순화

#### 코드 추적
- 실제 함수의 실행 경로 추적
- 함수 지표 모니터링 (예를 들어 CPU 사용률이나 메모리 사용량 등)
- 함수의 실행 시간 측정
- 언제 함수가 실행되고 전달된 파라미터는 무엇인지 로깅

---

## 데코레이터의 활용 - 흔한 실수 피하기

효과적인 데코레이터를 만들기 위해 피해야할 몇 가지 공통된 사항을 살펴본다.

### 래핑된 원본 객체의 데이터 보존

### 데코레이터 부작용 처리

#### 데코레이터 부작용의 잘못된 처리

`decorator_wrong_run1.py`

#### 데코레이터의 부작용의 활용

`decorator_wrong_run2.py`

데코레이터는 래핑된 객체를 변경하지도, 동작 방식을 수정하지도 않고 원래 함수 그대로를 반환하고 있다.
다만 여기에서 중요한 점은 래핑된 객체를 일부 수정하거나 수정하는 내부 함수를 정의했다고 해도 결과 객체를 외부에 노출하는 코드가 있어야 한다는 점이다.

"외부"라는 단어에 주목하자. 이전까지는 꼭 필요한 개념이 아니었지만 이제 결과 객체가 같은 클로저에 있지 않고 외부 스코프에 있으며 여기서 데코레이팅한 것만으로
스스로 결과 객체에 저장된다.

### 어느 곳에서나 동작하는 데코레이터 만들기


---

<!-- 글 뒷 부분에 -->
<a name="footnote_1">1</a>: 타이핑의 수고를 덜어주기 위해 다른 표현으로 코딩할 수 있게 해주는 기능을 말함. i = i + 1을 i++도 허락해준다면 그 느낌이 얼마나 달콤할까?

<a name="footnote_2">2</a>: indirection은 a=1; b=a; c=b;처럼 실제 값을 직접적인 경로를 통해 가져오는 것이 아니라 간접적인 경로를 거친 다음에 가져오기때문에 간접 참조라고 부른다.
