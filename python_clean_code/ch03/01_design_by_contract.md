# 계약에 의한 디자인 - Design by Contract

애플리케이션의 책임을 나누어 레이어나 컴포넌트로 분리한 경우가 있다.

컴포넌트는 기능을 숨겨 캡슐화하고 함수를 사용할 고객에게는 **애플리케이션 프로그래밍 인터페이스(Application Programming Interface - API)** 를 노출해야 한다.

예를 들어 정수를 파라미터로 사용하는 함수에 문자열을 파라미터로 전달하면 기대한 것과 다르게 동작할 것이 분명하다.

코드가 정상적으로 동작하기 위해 기대하는 것과 호출자가 반환 받기를 기대하는 것은 디자인의 하나가 되어야 한다. 여기서 **계약(contract)** 이라는 개념이 생긴다.

계약에 의한 다지안이란 이런 것이다. 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약을 먼저 한 다음, 계약을 어겼을 경우는 명시적으로 왜 계속할 수 없는지 예외를 발생시키라는 것이다.

계약은 주로 사전조건과 사후조건을 명시하지만 때로는 불변식과 부작용을 기술한다.
- **사전조건(precondition)** : 코드가 실행되기 전에 체크해야 하는 것들이다. 예를 들어 파라미터 유효성 검사가 있다. 이러한 작업은 호출자에게 부과된 임무이다.
- **사후조건(postcondition)** : 사전조건과 반대로 여기서는 함수 반환 값의 유효성 검사가 수행된다. 호출자가 기대한 것을 제대로 받았는지 확인하기 위해 수행한다.
- **불변식(invariant)** : 때로는 함수의 docstring에 불변식에 대해 문서화하는 것이 좋다. 불변식은 함수가 실행되는 동안에 일정하게 유지되는 것으로 함수의 로직에 문제가 없는지 확인하기 위한 것이다.
- **부작용(side-effect)** : 선택적으로 코드의 부작용을 docstring에 언급하기도 한다.

이상적으로는 이 모든 것들을 소프트웨어 컴포넌트 계약서의 일부로 문서화해야 하지만, 처음 2개인 사전조건과 사후조건만 저수준(코드) 레벨에서 강제한다.

이렇게 계약에 의해 디자인을 하는 이유는 **오류가 발생할 때 쉽게 찾아낼 수 있기 때문이다.** 더 중요한 것은 **잘못된 가정 하에 코드의 핵심 부분이 실행되는 것을 방지하기 위해서이다.** 이렇게 하면 책임의 한계를 명확히 하는데 도움이 된다. 만약 호출자가 잘못된 인자를 제공했다면 어디를 고쳐야 할까?

사전조건은 클라이언트와 연관되어 있다. 클라이언트는 코드를 실행하기 위해 사전에 약속한 조건을 준수해야만 한다. 반대로 사후조건은 컴포넌트와 연관되어 있다. 컴포넌트는 클라이언트가 확인하고 강제할 수 있는 값을 보장을 해야 한다.

특히 사전조건은 런타임 중에 확인할 수 있다는 점을 기억하는 것이 중요하다. 만약 사전조건에 맞지 않는다면 실행하지 않아야 한다. 왜냐하면 조건에 맞지 않는데 실행하는 것이 이치에 맞지 않을뿐더러 상황을 더 악화시킬 수 있기 때문이다.

## 사전조건(precondition)

사전조건은 함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것을 말한다. 이러한 검사의 일부는 이미 "코드 포메팅과 도구 소개"에서 소개한 mypy와 같은 정적 분석 도구를 사용하여 조기에 발견할 수 있지만 이러한 검사로는 충분하지 않다.

이제 문제는 이 유효성 검사를 어디서 할지이다. 클라이언트가 함수를 호출하기 전에 모든 유효성 검사를 하도록 할 것인지, 함수가 자체적으로 로직을 실행하기 전에 검사하도록 할 것인지에 대한 문제이다. 전자는 **관용적인(tolerant) 접근법**이다. 왜냐하면 함수가 어떤 값이라도 (심지어 깨진 데이터도) 수용하기 때문이다. 반면 후자는 **까다로운(demanding) 접근법**에 해당한다.

일반적으로 가장 안전하고 견고한 방법이며 업계에서도 가장 널리 쓰이는 방법이다.

검증 로직을 클라이언트에 두거나 함수 자체에 두어야 한다. 중복 제거 원칙을 항상 마음속에 간직해야 한다.

## 사후조건(postcondition)

사후조건은 메서드 또는 함수가 반환된 후의 상태를 강제하는 계약의 일부이다.

사후조건을 사용하여 클라이언트가 필요로 하는 모든 것을 검사할 수 있다. 메서드가 적절히 실행되었다면 계약이 이루어졌으므로 사후조건 검증에 통과하고 클라이언트는 반환 객체를 아무 문제없이 사용할 수 있어야 한다.

## 파이썬스러운 계약

아마도 이를 적용하는 가장 좋은 방법은 메서드, 함수 및 클래스에 RuntimeError 에외 또는 ValueError 예외를 발생시키는 제어 메커니즘을 추가하는 것이다. 앞에서 언급한 예외는 가장 일반적인 예외이지만 문제를 정확하게 특정하기 어려우면 사용자 정의 예외를 만드는 것이 가장 좋다.

또한 코드를 가능한 한 격리된 상태로 유지하는 것이 좋다. 즉 사전조건에 대한 검사, 사후조건에 대한 검사 그리고 핵심 기능에 대한 구현을 구분하는 것이다. 더 작은 함수를 생성하여 해결할 수도 있지만 데코레이터를 사용하는 것이 흥미로운 대안이 될 수 있다.

## 계약에 의한 디자인(DbC) - 결론

디자인 원칙의 주된 가치는 문제가 있는 부분을 효과적으로 식별하는데 있다. 계약을 정의함으로써 런타임 시 오류가 발생했을 때 코드의 어떤 부분이 손상되었는지 계약이 파손되었는지가 명확해진다.

이 원칙을 따르게 되면 코드가 더욱 견고해진다.

또한 프로그램의 구조를 명확히 하는 목적으로도 사용된다. 계약은 명시적으로 함수나 메서드가 정상 동작하기 위해 기대하는 것이 무엇인지, 무엇을 기대할 수 있는지 정의한다.

애플리케이션의 핵심 논리뿐만 아니라 계약을 작성해야하므로 추가 작업이 발생한다. 또한 이러한 계약에 대한 단위 테스트를 추가해야 할 수 있다. 그러나 이 방법을 통해 얻은 품질은 장기적으로 보상된다. 따라서 애플리케이션의 중요한 구성 요소에 대해서는 이 원칙을 따르는 것이 좋다. 그럼에도 불구하고 이 방법이 효과적이기 위해서는 무엇을 기꺼이 검증할 것인지 신중히 검토해봐야 하며 이는 굉장히 중요한 부분이다.

예를 들어 함수에 제공된 파라미터의 올바른 데이터 타입만 검사하는 계약을 정의하는 것은 별로 의미가 없다. 많은 프로그래머는 그렇게 하는 것은 파이썬을 정적 타입을 가진 언어로 만드는 것과 비슷한 것이라고 주장한다. 이런 주장과 별개로 Mypy와 같은 도구를 함께 사용하면 이 목적을 훨씬 효과적이고 적은 노력으로 이룰 수 있는 것이 사실이다. 이를 염두에 두고 함수에 전달되는 객체의 속성과 반환 값을 검사하고 이들이 유지해야 하는 조건을 확인하는 등의 작업을 하는 것은 실질적인 가치가 있다.

